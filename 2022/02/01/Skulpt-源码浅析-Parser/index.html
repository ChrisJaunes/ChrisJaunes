<!DOCTYPE html>
<html lang="en" >
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<meta name="description" content="欢迎来的ChrisJaunes的世界">
	<meta name="keywords" content="chrisjaunes">
	<title>Skulpt-源码浅析-Parser - ChrisJaunes</title>
	
	<link rel="shortcut icon" href="/ChrisJaunes/imgs/avatar.jpg"/>
	
<link rel="stylesheet" href="/ChrisJaunes/css/style.css">

	
<link rel="stylesheet" href="https://netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

<meta name="generator" content="Hexo 5.3.0"></head>
<body>
	<div class="main-con">
<nav class="nav cl">
    <ul class="cl nav-list">
        <li>
            <a href="/ChrisJaunes/" class="">
                <i class="fa fa-home"></i> 
                <span>主页</span>
            </a>
        </li>
        <li>
            <a href="/ChrisJaunes/archives/" class="">
                <i class=" fa-"></i> 
                <span>归档</span>
            </a>
        </li>
        <li>
            <a href="javascript:void(0)" class="">
                <i class=" fa-"></i> 
                <span>关于</span>
                <span class="drop-flag fa fa-angle-down"></span>
            </a>
            <dl>
                <li>
                    <a href="/ChrisJaunes/about" class="">
                    <i class=" fa-"></i>
                    <span>关于本站</span>
                    </a>
                </li>
            </dl>
        </li>
    </ul>
    <ul class="cl nav-tool">
        <li>
            <a target="_blank" rel="noopener" href="https://github.com/ChrisJaunes">
                <i class="fa fa-github"></i>
            </a>
        </li>
        <li>
            <a href="mailto:judgehuang@tencent.com">
                <i class="fa fa-envelope"></i>
            </a>
        </li>
        <li>
            <a href="javascript:void(0)" class="nav-search-btn">
                <i class="fa fa-search"></i>
            </a>
        </li>
    </ul>
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="nav-search"><input type="search" name="q" class="nav-search-input" placeholder="search..."><input type="hidden" name="sitesearch" value="https://chrisjaunes.github.io"></form>
</nav>

        
<div class="con-wrap fadeToTop">
    <section class="article-area">
        
<article class="article">
    <div class="article-wrap">
        <h2 class="article-title cl">
            <a href="/ChrisJaunes/2022/02/01/Skulpt-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90-Parser/" title="Skulpt-源码浅析-Parser">
                Skulpt-源码浅析-Parser
            </a>
        </h2>
        <ul class="article-extra" style="margin-bottom: 20px">
            <li class="article-time">
                2022-02-01
            </li> 
            <li class="article-category">
                <ol class="category-list cl">
                    <i class="fa fa-folder-o"></i>
                        <li><a href="/categories/Skulpt/">Skulpt</a></li>
                </ol>
            </li>
        </ul>
        <div class="article-description">
            <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Skulpt中Parser是一个从<a target="_blank" rel="noopener" href="https://github.com/python/cpython/tree/3.10/Lib/lib2to3/">cpython的lib2to3</a>派生的解析器</p>
<p>该Parser采用了自底向上的语法分析，也就是从分析树的底部(叶节点)向顶部(根节点)方向构造分析树。</p>
<p>注: Skulpt 后来搞了一个 skulpt_parser 用于 python3.9 语法解析。python3.9提出了一个 新的 使用<a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0617/">LL(1)</a>的 Parser。</p>
<h2><span id="zi-di-xiang-shang-fen-xi">自底向上分析</span><a href="#zi-di-xiang-shang-fen-xi" class="header-anchor"> </a></h2>
<p>自底向上的语法分析采用最左归约方式（反向构造最右推导），其通用的分析框架为 移入-归约分析(Shift-Reduce Parsing)。</p>
<h3><span id="yi-ru-gui-yue-fen-xi">移入-归约分析</span><a href="#yi-ru-gui-yue-fen-xi" class="header-anchor"> </a></h3>
<p>移入-归约分析的工作过程</p>
<blockquote>
<ol>
<li>在对输入串的一次从左到右扫描过程中，语法分析器将零个或多个输入符号移入到栈的顶端，<br>
直到它可以对栈顶的一个文法符号串β进行归约为止</li>
<li>然后，它将β归约为某个产生式的左部</li>
<li>语法分析器不断地重复这个循环，直到它检测到一个语法错误，或者栈中包含了开始符号且输入缓冲区为空(当进入这样的格局时，语法分析器停止运行 并宣称成功完成了语法分析)为止</li>
</ol>
</blockquote>
<p>移入-归约分析器可采取的4种动作</p>
<blockquote>
<ol>
<li>移入：将下一个输入符号移到栈的顶端</li>
<li>归约：被归约的符号串的右端必然处于栈顶。语法分析器在栈中确定这个串的左端，并决定用哪个非终结符来替换这个串</li>
<li>接收：宣布语法分析过程成功完成</li>
<li>报错：发现一个语法错误，并调用错误恢复子例程</li>
</ol>
</blockquote>
<h3><span id="lr-fen-xi-fa">LR分析法</span><a href="#lr-fen-xi-fa" class="header-anchor"> </a></h3>
<blockquote>
<p>LR文法(Knuth, 1963) 是最大的、可以构造出相应移入-归约语法分析器的文法类</p>
<ol>
<li>L: 对输入进行从左到右的扫描</li>
<li>R: 反向构造出一个最右推导序列</li>
<li>K: 需要向前查看k个输入符号的LR分析。 k = 0 和 k = 1 这两种情况具有实践意义。当省略(k)时，表示k=1</li>
</ol>
</blockquote>
<p>LR分析器的总体结构：<br>
<img src="LR-overall-structure.png" alt="LR分析器的总体结构"></p>
<p>LR算法流程：<br>
<img src="LR-algorithm.png" alt="LR算法流程"></p>
<h2><span id="skulpt-parser">Skulpt Parser</span><a href="#skulpt-parser" class="header-anchor"> </a></h2>
<h3><span id="parse">parse</span><a href="#parse" class="header-anchor"> </a></h3>
<p>parse 需要 filename、input 参数，其中：filename 被 makeParser 用于构造 Parser对象 ， input 被 readline 用于构造 字符流。</p>
<p>Sk._tokenize 是一个词法分析器，解析 字符流 形成 符号流，编码为utf-8</p>
<p>对于字符流调用回调函数yield_，yield_需要<a target="_blank" rel="noopener" href="https://github.com/skulpt/skulpt/blob/master/src/tokenize.js#L17">TokenInfo</a>类型的对象</p>
<p>回调函数中调用了 parser.addtoken 进行语法分析</p>
<p>至于分支 tokenInfo.type === T_COMMENT || tokenInfo.type === T_NL || tokenInfo.type === T_ENCODING 里的代码有什么用，我也不知道</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        Parser parse 相关源码
    </div>
    <div class="spoiler-content">
        <p><a target="_blank" rel="noopener" href="https://github.com/skulpt/skulpt/blob/master/src/parser.js#L287">源码</a></p>
<pre><code class="hljs js">Sk.parse = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">filename, input</span>) </span>&#123;
    <span class="hljs-keyword">var</span> T_COMMENT = Sk.token.tokens.T_COMMENT;
    <span class="hljs-keyword">var</span> T_NL = Sk.token.tokens.T_NL;
    <span class="hljs-keyword">var</span> T_OP = Sk.token.tokens.T_OP;
    <span class="hljs-keyword">var</span> T_ENDMARKER = Sk.token.tokens.T_ENDMARKER;
    <span class="hljs-keyword">var</span> T_ENCODING = Sk.token.tokens.T_ENCODING;

    <span class="hljs-keyword">var</span> endmarker_seen = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> parser = makeParser(filename);

    <span class="hljs-comment">// 由于lines.pop()因此需要reverse()</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readline</span>(<span class="hljs-params">input</span>) </span>&#123;
        <span class="hljs-keyword">var</span> lines = input.split(<span class="hljs-string">&quot;\n&quot;</span>).reverse().map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">l</span>) </span>&#123; <span class="hljs-keyword">return</span> l + <span class="hljs-string">&quot;\n&quot;</span>; &#125;);
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
            <span class="hljs-keyword">if</span> (lines.length === <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Sk.builtin.Exception(<span class="hljs-string">&quot;EOF&quot;</span>);
            &#125;
            <span class="hljs-keyword">return</span> lines.pop();
        &#125;;
    &#125;

    Sk._tokenize(filename, readline(input), <span class="hljs-string">&quot;utf-8&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tokenInfo</span>) </span>&#123;
        <span class="hljs-comment">// tokenInfo.start[0]保存了token的开始行号，tokenInfo.start[1]保存了token的开始列号</span>
        <span class="hljs-comment">// tokenInfo.end[0]保存了token的结束行号，tokenInfo.end[1]保存了token的结束列号</span>
        <span class="hljs-comment">// tokenInfo.value保存了token</span>
        <span class="hljs-keyword">var</span> s_lineno = tokenInfo.start[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">var</span> s_column = tokenInfo.start[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">var</span> type = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> prefix, lineno, column;

        <span class="hljs-keyword">if</span> (tokenInfo.type === T_COMMENT || tokenInfo.type === T_NL || tokenInfo.type === T_ENCODING) &#123;
            prefix += tokenInfo.value;
            lineno = tokenInfo.end[<span class="hljs-number">0</span>];
            column = tokenInfo.end[<span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span> (tokenInfo.string[tokenInfo.string.length - <span class="hljs-number">1</span>] === <span class="hljs-string">&quot;\n&quot;</span>) &#123;
                lineno += <span class="hljs-number">1</span>;
                column = <span class="hljs-number">0</span>;
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 如果是运算符，用更加具体的type取代T_OP</span>
            <span class="hljs-keyword">if</span> (tokenInfo.type === T_OP) &#123;
                type = Sk.OpMap[tokenInfo.string];
            &#125;
            <span class="hljs-comment">// context 包含了 开始位置(tokenInfo.start), 结束位置(tokenInfo.end), 行(tokenInfo.line)</span>
            parser.addtoken(type || tokenInfo.type, tokenInfo.string, [tokenInfo.start, tokenInfo.end, tokenInfo.line]);

            <span class="hljs-keyword">if</span> (tokenInfo.type === T_ENDMARKER) &#123;
                endmarker_seen = <span class="hljs-literal">true</span>;
            &#125;
        &#125;
    &#125;);

    <span class="hljs-comment">// endmarker_seen 用于标记 输入是否残缺</span>
    <span class="hljs-keyword">if</span> (!endmarker_seen) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Sk.builtin.SyntaxError(<span class="hljs-string">&quot;incomplete input&quot;</span>, <span class="hljs-built_in">this</span>.filename);
    &#125;
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;cst&quot;</span>: parser.rootnode, <span class="hljs-string">&quot;flags&quot;</span>: parser.p_flags&#125;;
&#125;;</code></pre>
    </div>
</div>
<h3><span id="parser-de-gou-zao">Parser的构造</span><a href="#parser-de-gou-zao" class="header-anchor"> </a></h3>
<p>makeParser 用于构造一个Parser对象，需要传入filename和style，但实际上只要传入filename就好。当style为undefined时会被置为&quot;file_input&quot;，而Parser也仅支持&quot;file_input&quot;。</p>
<p>然后 makeParser 创建了一个 Parser对象，并且调用了 setup 方法，最后将 Parser对象 返回。</p>
<p>Parser对象 的 构造函数 需要 filename 和 grammar 两个参数。grammar就是LR分析器所需要的分析表，makeParser传入的实参是 Sk.ParseTables。Parser构造函数中还将 p_flags 赋值为 0，p_flags与<a target="_blank" rel="noopener" href="https://github.com/skulpt/skulpt/blob/master/src/parser.js#L168">输出</a>相关。</p>
<p>Sk.ParseTables 源码位于 <a target="_blank" rel="noopener" href="https://github.com/skulpt/skulpt/blob/master/gen/parse_tables.js">parse_tables.js</a>，该文件的生成脚本源码位于<a target="_blank" rel="noopener" href="https://github.com/skulpt/skulpt/blob/master/support/build/regenparser.js">regenparser.js</a>, 本质上使用了<a target="_blank" rel="noopener" href="https://github.com/skulpt/skulpt/tree/master/src/pgen/parser">pgen</a>中的代码生成 <a target="_blank" rel="noopener" href="https://github.com/skulpt/skulpt/blob/master/gen/parse_tables.js">parse_tables.js</a></p>
<p>setup 构造了 LR分析器所需要的状态符号栈。栈中元素包含属性 dfa、state 和 node，node 包含属性 type、value、context 和 children</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        Parser 构造相关源码
    </div>
    <div class="spoiler-content">
        <pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeParser</span> (<span class="hljs-params">filename, style</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (style === <span class="hljs-literal">undefined</span>) &#123;
        style = <span class="hljs-string">&quot;file_input&quot;</span>;
    &#125;
    <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Parser(filename, Sk.ParseTables);
    <span class="hljs-comment">// for closure&#x27;s benefit</span>
    <span class="hljs-keyword">if</span> (style === <span class="hljs-string">&quot;file_input&quot;</span>) &#123;
        p.setup(Sk.ParseTables.sym.file_input);
    &#125; <span class="hljs-keyword">else</span> &#123;
        Sk.asserts.fail(<span class="hljs-string">&quot;todo;&quot;</span>);
    &#125;
    <span class="hljs-keyword">return</span> p;
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parser</span> (<span class="hljs-params">filename, grammar</span>) </span>&#123;
    <span class="hljs-built_in">this</span>.filename = filename;
    <span class="hljs-built_in">this</span>.grammar = grammar;
    <span class="hljs-built_in">this</span>.p_flags = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
&#125;
Parser.prototype.setup = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">start</span>) </span>&#123;
    <span class="hljs-keyword">var</span> stackentry;
    <span class="hljs-keyword">var</span> newnode;
    start = start || <span class="hljs-built_in">this</span>.grammar.start;
    <span class="hljs-comment">//print(&quot;START:&quot;+start);</span>

    newnode =
    &#123;
        type    : start,
        value   : <span class="hljs-literal">null</span>,
        context : <span class="hljs-literal">null</span>,
        children: []
    &#125;;
    stackentry =
    &#123;
        dfa  : <span class="hljs-built_in">this</span>.grammar.dfas[start],
        state: <span class="hljs-number">0</span>,
        node : newnode
    &#125;;
    <span class="hljs-built_in">this</span>.stack = [stackentry];
    <span class="hljs-built_in">this</span>.used_names = &#123;&#125;;
&#125;;</code></pre>
<p>setup中 的 node 为 下图 中 的 E或id<br>
<img src="LR-ast.png" alt="LR-node"></p>

    </div>
</div>
<h3><span id="addtoken">addtoken</span><a href="#addtoken" class="header-anchor"> </a></h3>
<p><a target="_blank" rel="noopener" href="https://www.icourse163.org/learn/HIT-1002123007?tid=1002231003#/learn/content?type=detail&amp;id=1002978023">编译原理教学</a></p>
<p>addtoken 需要 type, value, context 三个参数</p>
<ul>
<li>例如 第2行第1列有个abc
<ol>
<li>type 为 Sk.token.tokens.T_NAME</li>
<li>value 为 abc</li>
<li>context 包含了 具体信息， 例如context[0][0]=2, context[0][1]=1</li>
</ol>
</li>
</ul>
<p>实际上就是 查表 然后进行移入归约操作</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        Parser addtoken相关源码
    </div>
    <div class="spoiler-content">
        <p><a target="_blank" rel="noopener" href="https://github.com/skulpt/skulpt/blob/master/src/parser.js#L73">源码</a></p>
<pre><code class="hljs js">Parser.prototype.addtoken = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, value, context</span>) </span>&#123;
    <span class="hljs-keyword">var</span> errline, itsfirst, itsdfa, state, v, t, newstate, i, a, arcs, first, states, tp;
    <span class="hljs-keyword">var</span> ilabel = <span class="hljs-built_in">this</span>.classify(type, value, context);

    OUTERWHILE:
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
        tp = <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length - <span class="hljs-number">1</span>];
        states = tp.dfa[<span class="hljs-number">0</span>];
        first = tp.dfa[<span class="hljs-number">1</span>];
        arcs = states[tp.state];

        <span class="hljs-comment">// LR算法 中的 查表 操作</span>
        <span class="hljs-keyword">for</span> (a = <span class="hljs-number">0</span>; a &lt; arcs.length; ++a) &#123;
            i = arcs[a][<span class="hljs-number">0</span>];
            newstate = arcs[a][<span class="hljs-number">1</span>];
            t = <span class="hljs-built_in">this</span>.grammar.labels[i][<span class="hljs-number">0</span>];
            v = <span class="hljs-built_in">this</span>.grammar.labels[i][<span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span> (ilabel === i) &#123;
                <span class="hljs-comment">// 本处进行归约操作</span>
                Sk.asserts.assert(t &lt; <span class="hljs-number">256</span>);
                <span class="hljs-built_in">this</span>.shift(type, value, newstate, context);
                <span class="hljs-comment">// pop while we are in an accept-only state</span>
                state = newstate;
                <span class="hljs-keyword">while</span> (states[state].length === <span class="hljs-number">1</span>
                    &amp;&amp; states[state][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] === <span class="hljs-number">0</span>
                    &amp;&amp; states[state][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] === state) &#123;
                    <span class="hljs-built_in">this</span>.pop();
                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stack.length === <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;
                    tp = <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length - <span class="hljs-number">1</span>];
                    state = tp.state;
                    states = tp.dfa[<span class="hljs-number">0</span>];
                    first = tp.dfa[<span class="hljs-number">1</span>];
                &#125;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt;= <span class="hljs-number">256</span>) &#123;
                itsdfa = <span class="hljs-built_in">this</span>.grammar.dfas[t];
                itsfirst = itsdfa[<span class="hljs-number">1</span>];
                <span class="hljs-keyword">if</span> (itsfirst.hasOwnProperty(ilabel)) &#123;
                    <span class="hljs-built_in">this</span>.push(t, <span class="hljs-built_in">this</span>.grammar.dfas[t], newstate, context);
                    <span class="hljs-keyword">continue</span> OUTERWHILE;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span> (findInDfa(arcs, [<span class="hljs-number">0</span>, tp.state])) &#123;
            <span class="hljs-built_in">this</span>.pop();
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stack.length === <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Sk.builtin.SyntaxError(<span class="hljs-string">&quot;too much input&quot;</span>, <span class="hljs-built_in">this</span>.filename);
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            errline = context[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Sk.builtin.SyntaxError(<span class="hljs-string">&quot;bad input&quot;</span>, <span class="hljs-built_in">this</span>.filename, errline, context);
        &#125;
    &#125;
&#125;;</code></pre>
    </div>
</div>
<h3><span id="classify">classify</span><a href="#classify" class="header-anchor"> </a></h3>
<p>classify 将 终结符类型 转成 对应数字</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        Parser classify相关源码
    </div>
    <div class="spoiler-content">
        <pre><code class="hljs js">Parser.prototype.classify = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, value, context</span>) </span>&#123;
    <span class="hljs-keyword">var</span> ilabel;
    <span class="hljs-keyword">if</span> (type === Sk.token.tokens.T_NAME) &#123;
        <span class="hljs-built_in">this</span>.used_names[value] = <span class="hljs-literal">true</span>;
        <span class="hljs-comment">// 是不是 keywords</span>
        ilabel = <span class="hljs-built_in">this</span>.grammar.keywords.hasOwnProperty(value) &amp;&amp; <span class="hljs-built_in">this</span>.grammar.keywords[value];

        <span class="hljs-comment">// Check for handling print as a builtin function</span>
        <span class="hljs-keyword">if</span>(value === <span class="hljs-string">&quot;print&quot;</span> &amp;&amp; (<span class="hljs-built_in">this</span>.p_flags &amp; Parser.CO_FUTURE_PRINT_FUNCTION || Sk.__future__.print_function === <span class="hljs-literal">true</span>)) &#123;
            ilabel = <span class="hljs-literal">false</span>; <span class="hljs-comment">// ilabel determines if the value is a keyword</span>
        &#125;

        <span class="hljs-keyword">if</span> (ilabel) &#123; <span class="hljs-keyword">return</span> ilabel; &#125;
    &#125;
    ilabel = <span class="hljs-built_in">this</span>.grammar.tokens.hasOwnProperty(type) &amp;&amp; <span class="hljs-built_in">this</span>.grammar.tokens[type];
    <span class="hljs-keyword">if</span> (!ilabel) &#123;
        <span class="hljs-comment">// throw new Sk.builtin.SyntaxError(&quot;bad token&quot;, type, value, context);</span>
        <span class="hljs-comment">// Questionable modification to put line number in position 2</span>
        <span class="hljs-comment">// like everywhere else and filename in position 1.</span>
        <span class="hljs-keyword">let</span> descr = <span class="hljs-string">&quot;#&quot;</span>+type;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> Sk.token.tokens) &#123;
            <span class="hljs-keyword">if</span> (Sk.token.tokens[i] == type) &#123;
                descr = i;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;

        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Sk.builtin.SyntaxError(<span class="hljs-string">&quot;bad token &quot;</span> + descr, <span class="hljs-built_in">this</span>.filename, context[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], context);
    &#125;
    <span class="hljs-keyword">return</span> ilabel;
&#125;;</code></pre>
    </div>
</div>
<h3><span id="push">push</span><a href="#push" class="header-anchor"> </a></h3>
<p>Parser 的 push 方法 用于添加 非终结符</p>
<p>push方法 将 栈顶元素 的 state 改为 newstate</p>
<p>该方法用 type、context 构造了 newnode，进而用newdfa、newnode构造了新的对象入栈</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        Parser push相关源码
    </div>
    <div class="spoiler-content">
        <p><a target="_blank" rel="noopener" href="https://github.com/skulpt/skulpt/blob/master/src/parser.js#L219">源码</a></p>
<pre><code class="hljs js">Parser.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, newdfa, newstate, context</span>) </span>&#123;
    <span class="hljs-keyword">var</span> dfa = <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length - <span class="hljs-number">1</span>].dfa;
    <span class="hljs-keyword">var</span> node = <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length - <span class="hljs-number">1</span>].node;
    <span class="hljs-keyword">var</span> newnode = &#123;
        type      : type,
        value     : <span class="hljs-literal">null</span>,
        lineno    : context[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],      <span class="hljs-comment">// throwing away end here to match cpython</span>
        col_offset: context[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>],
        children  : []
    &#125;;
    <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length - <span class="hljs-number">1</span>] = &#123;
        dfa  : dfa,
        state: newstate,
        node : node
    &#125;;
    <span class="hljs-built_in">this</span>.stack.push(&#123;
        dfa  : newdfa,
        state: <span class="hljs-number">0</span>,
        node : newnode
    &#125;);
&#125;;</code></pre>
    </div>
</div>
<h3><span id="shift">shift</span><a href="#shift" class="header-anchor"> </a></h3>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        Parser shift 相关源码
    </div>
    <div class="spoiler-content">
        <p><a target="_blank" rel="noopener" href="https://github.com/skulpt/skulpt/blob/master/src/parser.js#L196">源码</a></p>
<pre><code class="hljs js">Parser.prototype.shift = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, value, newstate, context</span>) </span>&#123;
    <span class="hljs-keyword">var</span> dfa = <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length - <span class="hljs-number">1</span>].dfa;
    <span class="hljs-keyword">var</span> state = <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length - <span class="hljs-number">1</span>].state;
    <span class="hljs-keyword">var</span> node = <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length - <span class="hljs-number">1</span>].node;
    <span class="hljs-keyword">var</span> newnode = &#123;
        type      : type,
        value     : value,
        lineno    : context[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],
        col_offset: context[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>],
        children  : <span class="hljs-literal">null</span>
    &#125;;
    <span class="hljs-keyword">if</span> (newnode) &#123;
        node.children.push(newnode);
    &#125;
    <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length - <span class="hljs-number">1</span>] = &#123;
        dfa  : dfa,
        state: newstate,
        node : node
    &#125;;
&#125;;</code></pre>
    </div>
</div>
<h3><span id="pop">pop</span><a href="#pop" class="header-anchor"> </a></h3>
<p>弹出状态符号栈的栈顶元素。</p>
<p>如果栈内不止一个元素,自底向上构造语法树; 否则rootnode指向语法树根节点.</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        Parser pop相关源码
    </div>
    <div class="spoiler-content">
        <p><a target="_blank" rel="noopener" href="https://github.com/skulpt/skulpt/blob/master/src/parser.js#L245">源码</a></p>
<pre><code class="hljs js">Parser.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">var</span> node;
    <span class="hljs-keyword">var</span> pop = <span class="hljs-built_in">this</span>.stack.pop();
    <span class="hljs-keyword">var</span> newnode = pop.node;
    <span class="hljs-keyword">if</span> (newnode) &#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stack.length !== <span class="hljs-number">0</span>) &#123;
            node = <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length - <span class="hljs-number">1</span>].node;
            node.children.push(newnode);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-built_in">this</span>.rootnode = newnode;
            <span class="hljs-built_in">this</span>.rootnode.used_names = <span class="hljs-built_in">this</span>.used_names;
        &#125;
    &#125;
&#125;;</code></pre>
    </div>
</div>
<h2><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor"> </a></h2>


	<div class="row">
    <embed src="语法分析-自底向上.pdf" width="100%" height="550" type="application/pdf">
	</div>


<link rel="stylesheet" href="/ChrisJaunes/css/spoiler.css" type="text/css"><script src="/ChrisJaunes/js/spoiler.js" type="text/javascript" async></script>
        </div>
        <div class="article-tags">
            <ul class="tags-list cl">
                <li><a href="/ChrisJaunes/tags/Skulpt/"><i class="fa fa-tag"></i>Skulpt</a></li>
            </ul>
        </div>
        <div class="article-pagination cl">
            <div class="pagination-prev">
                <a href="/ChrisJaunes/2022/04/02/D3-Format-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/">上一篇：D3-Format-源码浅析</a>
            </div>
            <div class="pagination-next">
                <a href="/ChrisJaunes/2022/01/24/Presto-SqlParser-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90-AstBuilder%E7%B1%BB/">下一篇：Presto-SqlParser-源码浅析-AstBuilder类</a>
            </div>
        </div> 
        
            <link rel="stylesheet" href="https://unpkg.com/gitalk@latest/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<script src="https://priesttomb.github.io/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    new Gitalk({
        clientID: '0ba2ec4192b1d2fb9cb6',
        clientSecret: '85deadc0e6ed5bdf825a822ab2fdfbad69401fb9',
        repo: 'ChrisJaunes',
        owner: 'ChrisJaunes',
        admin: 'ChrisJaunes',
        id: md5(location.pathname),
        distractionFreeMode: true,
        proxy: 'https://vercel.prohibitorum.top/github_access_token'
    }).render('gitalk-container')
</script>
        
    </div>

</article>
    </section>
        
<section class="tool-area">

    <div class="toolbar">
        

        
        <div class="widget-post widget" style="order: 1 ">
            <h2 class="widget-title"><i class="fa fa-file-text"></i> Recent articles</h2>
            <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/ChrisJaunes/2022/09/05/DRF-ModelSerializer-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90-%E5%BA%8F%E5%88%97%E5%8C%96/">DRF-ModelSerializer-源码浅析-序列化</a></li><li class="post-list-item"><a class="post-list-link" href="/ChrisJaunes/2022/08/02/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-mock%E6%B5%85%E6%9E%90-1-%E6%A6%82%E8%BF%B0/">单元测试-mock浅析-1-概述</a></li><li class="post-list-item"><a class="post-list-link" href="/ChrisJaunes/2022/07/07/Adfuller-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Adfuller-学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/ChrisJaunes/2022/04/26/ZooKeeper-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3/">ZooKeeper-源码浅析-数据模型相关</a></li><li class="post-list-item"><a class="post-list-link" href="/ChrisJaunes/2022/04/25/ZooKeeper-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/">ZooKeeper-数据模型</a></li><li class="post-list-item"><a class="post-list-link" href="/ChrisJaunes/2022/04/25/ZooKeeper-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">ZooKeeper-环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/ChrisJaunes/2022/04/02/D3-Format-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/">D3-Format-源码浅析</a></li><li class="post-list-item"><a class="post-list-link" href="/ChrisJaunes/2022/02/01/Skulpt-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90-Parser/">Skulpt-源码浅析-Parser</a></li></ul>
        </div>
        

        
        <div class="widget-tags widget" style="order: 2 ">
            <h2 class="widget-title"><i class="fa fa-tags"></i> Tag</h2>
            <a href="/ChrisJaunes/tags/Blockly/" style="font-size: 15px;">Blockly</a> <a href="/ChrisJaunes/tags/C/" style="font-size: 15px;">C++</a> <a href="/ChrisJaunes/tags/D3/" style="font-size: 10px;">D3</a> <a href="/ChrisJaunes/tags/Http/" style="font-size: 17.5px;">Http</a> <a href="/ChrisJaunes/tags/HttpServer/" style="font-size: 17.5px;">HttpServer</a> <a href="/ChrisJaunes/tags/Java/" style="font-size: 20px;">Java</a> <a href="/ChrisJaunes/tags/Jupyter/" style="font-size: 12.5px;">Jupyter</a> <a href="/ChrisJaunes/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/ChrisJaunes/tags/Net/" style="font-size: 12.5px;">Net</a> <a href="/ChrisJaunes/tags/Presto/" style="font-size: 12.5px;">Presto</a> <a href="/ChrisJaunes/tags/Python/" style="font-size: 17.5px;">Python</a> <a href="/ChrisJaunes/tags/Servlet/" style="font-size: 12.5px;">Servlet</a> <a href="/ChrisJaunes/tags/Skulpt/" style="font-size: 10px;">Skulpt</a> <a href="/ChrisJaunes/tags/Sql%E8%A7%A3%E6%9E%90/" style="font-size: 12.5px;">Sql解析</a> <a href="/ChrisJaunes/tags/TensorFlow/" style="font-size: 10px;">TensorFlow</a> <a href="/ChrisJaunes/tags/ZooKeeper/" style="font-size: 15px;">ZooKeeper</a> <a href="/ChrisJaunes/tags/container/" style="font-size: 10px;">container</a> <a href="/ChrisJaunes/tags/django/" style="font-size: 10px;">django</a> <a href="/ChrisJaunes/tags/metakernel/" style="font-size: 10px;">metakernel</a> <a href="/ChrisJaunes/tags/python/" style="font-size: 10px;">python</a> <a href="/ChrisJaunes/tags/web/" style="font-size: 10px;">web</a> <a href="/ChrisJaunes/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 15px;">分布式</a> <a href="/ChrisJaunes/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">单元测试</a> <a href="/ChrisJaunes/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 10px;">序列化</a> <a href="/ChrisJaunes/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90/" style="font-size: 10px;">时间序列分析</a>
        </div>
        

        
            <div class="widget-categories widget" style="order: 3 ">
                <h2 class="widget-title"><i class="fa fa-folder-open"></i> Categories</h2>
                 <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/Blockly/">Blockly</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/Blockly/BlocklyJupyter/">BlocklyJupyter</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/C/">C++</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/C/%E6%A0%87%E5%87%86%E5%BA%93/">标准库</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/D3/">D3</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/Java/">Java</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/Java/Http/">Http</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/Java/Http/HttpServer/">HttpServer</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/Java/Servlet/">Servlet</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/Presto/">Presto</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/Presto/SqlParser/">SqlParser</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/Python/">Python</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/Python/Docx/">Docx</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/Python/Json/">Json</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/Python/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/">内置函数</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/Skulpt/">Skulpt</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/TensorFlow/">TensorFlow</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/TensorFlow/env/">env</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/django/">django</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/programing-language/">programing_language</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/programing-language/%E6%AF%94%E8%BE%83%E5%AD%A6%E4%B9%A0/">比较学习</a><span class="category-list-count">6</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/%E5%88%86%E5%B8%83%E5%BC%8F/ZooKeeper/">ZooKeeper</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">单元测试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ChrisJaunes/categories/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90/">时间序列分析</a><span class="category-list-count">1</span></li></ul> 
            </div>         
        
    </div>
</section>
</div>


<footer class="footer">
	<p class="footer-intro">
		
		@2022 ChrisJaunes.
	</p>
	<p class="footer-intro">
			Powered By <a href="https://github.com/ChrisJaunes" target="_blank"> ChrisJaunes </a> |
			Hexo Powered By <a href="https://hexo.io/zh-cn/" target="_blank">hexo</a> |
			Theme Powered by ChrisJaunes 
	</p>
	<p class="footer-intro">
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
		<span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次 &nbsp;|&nbsp;</span>
		<span id="busuanzi_container_site_uv">访客数<span id="busuanzi_value_site_uv"></span>人次&nbsp;|&nbsp;</span>
		<span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span>次</span>
	</p>
</footer>




<div class="extend-tools" id="extend-tools" style="display: none;">
    <ul>
        <li class="tools-returnTop" title="Back to top"><i class="fa fa-angle-double-up"></i></li>
    </ul>
</div>

	</div>


<script src="/ChrisJaunes/js/org/jquery.min.js"></script>


<script src="/ChrisJaunes/js/extend.js"></script>

</body>
</html>